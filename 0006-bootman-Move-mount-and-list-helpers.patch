From a3d1955cf32538f7689d5aa7b1b5cd36c35be406 Mon Sep 17 00:00:00 2001
From: William Douglas <william.douglas@intel.com>
Date: Fri, 16 Nov 2018 14:32:56 -0800
Subject: [PATCH 3/4] bootman: Move mount and list helpers

Restructure where helpers are located in source files. Make a few
helper functions public as part of this restructure to enable
sharing.
---
 src/bootman/bootman.c         | 181 ++++++++++++++++++++++++++++++++++
 src/bootman/bootman_private.h |  18 ++++
 src/bootman/update.c          | 177 ---------------------------------
 tests/check-core.c            |   4 +-
 4 files changed, 201 insertions(+), 179 deletions(-)

diff --git a/src/bootman/bootman.c b/src/bootman/bootman.c
index 7007f0b..50dcf11 100644
--- a/src/bootman/bootman.c
+++ b/src/bootman/bootman.c
@@ -14,6 +14,7 @@
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <sys/mount.h>
 #include <sys/utsname.h>
 #include <unistd.h>
 #include <ctype.h>
@@ -25,6 +26,7 @@
 #include "files.h"
 #include "log.h"
 #include "nica/files.h"
+#include "system_stub.h"
 
 #include "config.h"
 
@@ -336,6 +338,185 @@ char *boot_manager_get_default_kernel(BootManager *self)
         return self->bootloader->get_default_kernel(self);
 }
 
+/**
+ * Sort by release number, putting highest first
+ */
+int kernel_compare_reverse(const void *a, const void *b)
+{
+        const Kernel *ka = *(const Kernel **)a;
+        const Kernel *kb = *(const Kernel **)b;
+
+        if (ka->meta.release > kb->meta.release) {
+                return -1;
+        }
+        return 1;
+}
+
+/**
+ * Unmount boot directory
+ */
+void umount_boot(char *boot_dir)
+{
+        /* Cleanup and umount */
+        LOG_INFO("Attempting umount of %s", boot_dir);
+        if (cbm_system_umount(boot_dir) < 0) {
+                LOG_WARNING("Could not unmount boot directory");
+        } else {
+                LOG_SUCCESS("Unmounted boot directory");
+        }
+}
+
+/**
+ * Mount boot directory
+ *
+ * Returns tri-state of -1 for error, 0 for already mounted and 1 for mount
+ * completed. *boot_directory should be free'd by caller.
+ */
+int mount_boot(BootManager *self, char **boot_directory)
+{
+        autofree(char) *abs_bootdir = NULL;
+        autofree(char) *boot_dir = NULL;
+        int ret = -1;
+        char *root_base = NULL;
+
+        if (!boot_directory) {
+                goto out;
+        }
+
+        /* Get our boot directory */
+        boot_dir = boot_manager_get_boot_dir(self);
+        if (!boot_dir) {
+                DECLARE_OOM();
+                goto out;
+        }
+
+        /* Prepare mounts */
+        LOG_INFO("Checking for mounted boot dir");
+        /* Already mounted at the default boot dir, nothing for us to do */
+        if (cbm_system_is_mounted(boot_dir)) {
+                LOG_INFO("boot_dir is already mounted: %s", boot_dir);
+                *boot_directory = strdup(boot_dir);
+                if (*boot_directory) {
+                        ret = 0;
+                }
+                goto out;
+        }
+
+        /* Determine root device */
+        root_base = self->sysconfig->boot_device;
+        if (!root_base) {
+                LOG_FATAL("Cannot determine boot device");
+                goto out;
+        }
+
+        abs_bootdir = cbm_system_get_mountpoint_for_device(root_base);
+
+        if (abs_bootdir) {
+                LOG_DEBUG("Boot device already mounted at %s", abs_bootdir);
+                /* User has already mounted the ESP somewhere else, use that */
+                if (!boot_manager_set_boot_dir(self, abs_bootdir)) {
+                        LOG_FATAL("Cannot initialise with premounted ESP");
+                        goto out;
+                }
+                /* Successfully using their premounted ESP, go use it */
+                LOG_INFO("Skipping to native update");
+                *boot_directory = boot_dir;
+                if (*boot_directory) {
+                        ret = 0;
+                }
+                goto out;
+        }
+
+        /* The boot directory isn't mounted, so we'll mount it now */
+        if (!nc_file_exists(boot_dir)) {
+                LOG_INFO("Creating boot dir");
+                nc_mkdir_p(boot_dir, 0755);
+        }
+        LOG_INFO("Mounting boot device %s at %s", root_base, boot_dir);
+        if (cbm_system_mount(root_base, boot_dir, "vfat", MS_MGC_VAL, "") < 0) {
+                LOG_FATAL("FATAL: Cannot mount boot device %s on %s: %s",
+                          root_base,
+                          boot_dir,
+                          strerror(errno));
+                goto out;
+        }
+        LOG_SUCCESS("%s successfully mounted at %s", root_base, boot_dir);
+
+        /* Reinit bootloader for non-image mode with newly mounted boot partition
+         * as it may have paths that already exist, and we must adjust for case
+         * sensitivity (ignorant) issues
+         */
+        if (!boot_manager_set_boot_dir(self, boot_dir)) {
+                LOG_FATAL("Cannot initialise with newly mounted ESP");
+                goto out;
+        }
+        *boot_directory = strdup(boot_dir);
+        if (*boot_directory) {
+                ret = 1;
+        } else {
+                umount_boot(boot_dir);
+        }
+
+out:
+        return ret;
+}
+
+/**
+ * List kernels available on the target
+ *
+ * Returns a list of kernels available to be run.
+ */
+char **boot_manager_list_kernels(BootManager *self)
+{
+        assert(self != NULL);
+        autofree(KernelArray) *kernels = NULL;
+        autofree(char) *boot_dir = NULL;
+        autofree(char) *default_kernel = NULL;
+        char **results;
+        int did_mount = -1;
+
+        /* Grab the available kernels */
+        kernels = boot_manager_get_kernels(self);
+        if (!kernels || kernels->len == 0) {
+                LOG_ERROR("No kernels discovered in %s, bailing", self->kernel_dir);
+                return NULL;
+        }
+
+        /* Sort them to ensure static ordering */
+        nc_array_qsort(kernels, kernel_compare_reverse);
+
+        /* TODO: decide how legacy device detection works */
+        /* For now legacy means /boot is on the / partition */
+        if ((self->sysconfig->wanted_boot_mask & BOOTLOADER_CAP_LEGACY) == BOOTLOADER_CAP_LEGACY) {
+                did_mount = 0;
+        } else {
+                did_mount = mount_boot(self, &boot_dir);
+        }
+        if (did_mount >= 0) {
+                default_kernel = boot_manager_get_default_kernel(self);
+                if (did_mount > 0) {
+                        umount_boot(boot_dir);
+                }
+        }
+
+        results = calloc(kernels->len + (size_t)1, sizeof(char *));
+        if (!results) {
+                DECLARE_OOM();
+                return NULL;
+        }
+        for (uint16_t i = 0; i < kernels->len; i++) {
+                const Kernel *k = nc_array_get(kernels, i);
+                if (streq(default_kernel, k->meta.bpath)) {
+                        results[i] = string_printf("* %s", k->meta.bpath);
+                } else {
+                        results[i] = string_printf("  %s", k->meta.bpath);
+                }
+        }
+        results[kernels->len] = NULL;
+
+        return results;
+}
+
 char *boot_manager_get_boot_dir(BootManager *self)
 {
         assert(self != NULL);
diff --git a/src/bootman/bootman_private.h b/src/bootman/bootman_private.h
index de60e80..9dbda77 100644
--- a/src/bootman/bootman_private.h
+++ b/src/bootman/bootman_private.h
@@ -48,6 +48,24 @@ bool boot_manager_install_kernel_internal(const BootManager *manager, const Kern
  */
 bool boot_manager_remove_kernel_internal(const BootManager *manager, const Kernel *kernel);
 
+/**
+ * Internal function to unmount boot directory
+ */
+void umount_boot(char *boot_dir);
+
+/**
+ * Internal function to mount the boot directory
+ *
+ * Returns tri-state of -1 for error, 0 for already mounted and 1 for mount
+ * completed. *boot_directory should be free'd by caller.
+ */
+int mount_boot(BootManager *self, char **boot_directory);
+
+/**
+ * Internal function to sort by Kernel structs by release number (highest first)
+ */
+int kernel_compare_reverse(const void *a, const void *b);
+
 /*
  * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
  *
diff --git a/src/bootman/update.c b/src/bootman/update.c
index 316bf67..1338865 100644
--- a/src/bootman/update.c
+++ b/src/bootman/update.c
@@ -28,183 +28,6 @@ static bool boot_manager_update_image(BootManager *self);
 static bool boot_manager_update_native(BootManager *self);
 static bool boot_manager_update_bootloader(BootManager *self);
 
-/**
- * Sort by release number, putting highest first
- */
-static int kernel_compare_reverse(const void *a, const void *b)
-{
-        const Kernel *ka = *(const Kernel **)a;
-        const Kernel *kb = *(const Kernel **)b;
-
-        if (ka->meta.release > kb->meta.release) {
-                return -1;
-        }
-        return 1;
-}
-
-/**
- * Unmount boot directory.
- */
-static void umount_boot(char *boot_dir)
-{
-        /* Cleanup and umount */
-        LOG_INFO("Attempting umount of %s", boot_dir);
-        if (cbm_system_umount(boot_dir) < 0) {
-                LOG_WARNING("Could not unmount boot directory");
-        } else {
-                LOG_SUCCESS("Unmounted boot directory");
-        }
-}
-
-/**
- * Returns tri-state of -1 for error, 0 for already mounted and 1 for mount
- * completed. *boot_directory should be free'd by caller.
- */
-static int mount_boot(BootManager *self, char **boot_directory)
-{
-        autofree(char) *abs_bootdir = NULL;
-        autofree(char) *boot_dir = NULL;
-        int ret = -1;
-        char *root_base = NULL;
-
-        if (!boot_directory) {
-                goto out;
-        }
-
-        /* Get our boot directory */
-        boot_dir = boot_manager_get_boot_dir(self);
-        if (!boot_dir) {
-                DECLARE_OOM();
-                goto out;
-        }
-
-        /* Prepare mounts */
-        LOG_INFO("Checking for mounted boot dir");
-        /* Already mounted at the default boot dir, nothing for us to do */
-        if (cbm_system_is_mounted(boot_dir)) {
-                LOG_INFO("boot_dir is already mounted: %s", boot_dir);
-                *boot_directory = strdup(boot_dir);
-                if (*boot_directory) {
-                        ret = 0;
-                }
-                goto out;
-        }
-
-        /* Determine root device */
-        root_base = self->sysconfig->boot_device;
-        if (!root_base) {
-                LOG_FATAL("Cannot determine boot device");
-                goto out;
-        }
-
-        abs_bootdir = cbm_system_get_mountpoint_for_device(root_base);
-
-        if (abs_bootdir) {
-                LOG_DEBUG("Boot device already mounted at %s", abs_bootdir);
-                /* User has already mounted the ESP somewhere else, use that */
-                if (!boot_manager_set_boot_dir(self, abs_bootdir)) {
-                        LOG_FATAL("Cannot initialise with premounted ESP");
-                        goto out;
-                }
-                /* Successfully using their premounted ESP, go use it */
-                LOG_INFO("Skipping to native update");
-                *boot_directory = boot_dir;
-                if (*boot_directory) {
-                        ret = 0;
-                }
-                goto out;
-        }
-
-        /* The boot directory isn't mounted, so we'll mount it now */
-        if (!nc_file_exists(boot_dir)) {
-                LOG_INFO("Creating boot dir");
-                nc_mkdir_p(boot_dir, 0755);
-        }
-        LOG_INFO("Mounting boot device %s at %s", root_base, boot_dir);
-        if (cbm_system_mount(root_base, boot_dir, "vfat", MS_MGC_VAL, "") < 0) {
-                LOG_FATAL("FATAL: Cannot mount boot device %s on %s: %s",
-                          root_base,
-                          boot_dir,
-                          strerror(errno));
-                goto out;
-        }
-        LOG_SUCCESS("%s successfully mounted at %s", root_base, boot_dir);
-
-        /* Reinit bootloader for non-image mode with newly mounted boot partition
-         * as it may have paths that already exist, and we must adjust for case
-         * sensitivity (ignorant) issues
-         */
-        if (!boot_manager_set_boot_dir(self, boot_dir)) {
-                LOG_FATAL("Cannot initialise with newly mounted ESP");
-                goto out;
-        }
-        *boot_directory = strdup(boot_dir);
-        if (*boot_directory) {
-                ret = 1;
-        } else {
-                umount_boot(boot_dir);
-        }
-
-out:
-        return ret;
-}
-
-/**
- * List kernels available on the target
- *
- * Returns a list of kernels available to be run.
- */
-char **boot_manager_list_kernels(BootManager *self)
-{
-        assert(self != NULL);
-        autofree(KernelArray) *kernels = NULL;
-        autofree(char) *boot_dir = NULL;
-        autofree(char) *default_kernel = NULL;
-        char **results;
-        int did_mount = -1;
-
-        /* Grab the available kernels */
-        kernels = boot_manager_get_kernels(self);
-        if (!kernels || kernels->len == 0) {
-                LOG_ERROR("No kernels discovered in %s, bailing", self->kernel_dir);
-                return NULL;
-        }
-
-        /* Sort them to ensure static ordering */
-        nc_array_qsort(kernels, kernel_compare_reverse);
-
-        /* TODO: decide how legacy device detection works */
-        /* For now legacy means /boot is on the / partition */
-        if ((self->sysconfig->wanted_boot_mask & BOOTLOADER_CAP_LEGACY) == BOOTLOADER_CAP_LEGACY) {
-                did_mount = 0;
-        } else {
-                did_mount = mount_boot(self, &boot_dir);
-        }
-        if (did_mount >= 0) {
-                default_kernel = boot_manager_get_default_kernel(self);
-                if (did_mount > 0) {
-                        umount_boot(boot_dir);
-                }
-        }
-
-        results = calloc(kernels->len + (size_t)1, sizeof(char *));
-        if (!results) {
-                DECLARE_OOM();
-                return NULL;
-        }
-        for (uint16_t i = 0; i < kernels->len; i++) {
-                const Kernel *k = nc_array_get(kernels, i);
-                if (streq(default_kernel, k->meta.bpath)) {
-                        results[i] = string_printf("* %s", k->meta.bpath);
-                } else {
-                        results[i] = string_printf("  %s", k->meta.bpath);
-                }
-        }
-        results[kernels->len] = NULL;
-
-        return results;
-}
-
 bool boot_manager_update(BootManager *self)
 {
         assert(self != NULL);
diff --git a/tests/check-core.c b/tests/check-core.c
index 83f7cd6..0d28ccb 100644
--- a/tests/check-core.c
+++ b/tests/check-core.c
@@ -141,7 +141,7 @@ START_TEST(bootman_parser_test)
 }
 END_TEST
 
-int kernel_compare(const void *a, const void *b)
+static int kernel_compare(const void *a, const void *b)
 {
         const Kernel *ka = *(const Kernel **)a;
         const Kernel *kb = *(const Kernel **)b;
@@ -152,7 +152,7 @@ int kernel_compare(const void *a, const void *b)
         return 1;
 }
 
-int kernel_compare_reverse(const void *a, const void *b)
+static int kernel_compare_reverse(const void *a, const void *b)
 {
         const Kernel *ka = *(const Kernel **)a;
         const Kernel *kb = *(const Kernel **)b;
-- 
2.19.1

